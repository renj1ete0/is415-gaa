[
  {
    "objectID": "exercises/icex10.html",
    "href": "exercises/icex10.html",
    "title": "In-Class Exercise 10: Modelling Geographical Accessibility",
    "section": "",
    "text": "Pacman assists us by helping us load R packages that we require, sf, SpatialAcc, tidyverse, reshape2, ggstatplot and tmap.\n\npacman::p_load(tmap, SpatialAcc, sf, ggstatsplot, reshape2, tidyverse, fca)\n\n\n\n\nThe following datasets are used:\n\n\n\nDataset Name\nSource\n\n\n\n\nURA Master Plan 2014 Subzone Boundary\ndata.gov.sg\n\n\n250m Hexagon GIS Data\nProf Kam\n\n\nEldercare\nProf Kam\n\n\nOD Matrix\nProf Kam"
  },
  {
    "objectID": "exercises/icex10.html#importing-geospatial-data",
    "href": "exercises/icex10.html#importing-geospatial-data",
    "title": "In-Class Exercise 10: Modelling Geographical Accessibility",
    "section": "2.1 Importing Geospatial Data",
    "text": "2.1 Importing Geospatial Data\nUsing the code chunks below with st_read(), we will import the three datasets we require for our analysis.\n\nmpsz <- st_read(dsn = \"In-Class_Ex10/data/geospatial\", layer = \"MP14_SUBZONE_NO_SEA_PL\")\n\nReading layer `MP14_SUBZONE_NO_SEA_PL' from data source \n  `C:\\renjie-teo\\IS415-GAA\\exercises\\In-Class_Ex10\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\nhexagons <- st_read(dsn = \"In-Class_Ex10/data/geospatial\", layer = \"hexagons\") \n\nReading layer `hexagons' from data source \n  `C:\\renjie-teo\\IS415-GAA\\exercises\\In-Class_Ex10\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3125 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n\n\n\neldercare <- st_read(dsn = \"In-Class_Ex10/data/geospatial\", layer = \"ELDERCARE\") \n\nReading layer `ELDERCARE' from data source \n  `C:\\renjie-teo\\IS415-GAA\\exercises\\In-Class_Ex10\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 120 features and 19 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14481.92 ymin: 28218.43 xmax: 41665.14 ymax: 46804.9\nProjected CRS: SVY21 / Singapore TM"
  },
  {
    "objectID": "exercises/icex10.html#updating-crs-information",
    "href": "exercises/icex10.html#updating-crs-information",
    "title": "In-Class Exercise 10: Modelling Geographical Accessibility",
    "section": "2.2 Updating CRS Information",
    "text": "2.2 Updating CRS Information\nNext, since the imported data is in EPSG:4326 (WGS84), we need to convert it from Geodetic Coordinate System to Projected Coordinate System in EPSG:3414 (SVY21). The code chunk below will do that:\n\nmpsz <- st_transform(mpsz, 3414)\neldercare <- st_transform(eldercare, 3414)\nhexagons <- st_transform(hexagons, 3414)\n\nNext, we will verify if the CRS has been updated successfully to SVY21.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\nYes, the CRS has been updated successfully to SVY21."
  },
  {
    "objectID": "exercises/icex10.html#cleaning-and-verifying-crs-information",
    "href": "exercises/icex10.html#cleaning-and-verifying-crs-information",
    "title": "In-Class Exercise 10: Modelling Geographical Accessibility",
    "section": "2.3 Cleaning and Verifying CRS Information",
    "text": "2.3 Cleaning and Verifying CRS Information\nAs there are many redundant fields in both the eldercare and hexagons dataset, we will reduce the amount of columns to those necessary for our analysis. Next, we will create two columns, capacity for eldercare and demand for hexagons with a constant value of 100 for exercise purposes.\nNote that we should use the exact capacity and demand values in real world scenarios.\n\neldercare <- eldercare %>%\n  select(fid, ADDRESSPOS) %>%\n  mutate(capacity = 100)\n\n\nhexagons <- hexagons %>%\n  select(fid) %>%\n  mutate(demand = 100)"
  },
  {
    "objectID": "exercises/icex10.html#importing-distance-matrix",
    "href": "exercises/icex10.html#importing-distance-matrix",
    "title": "In-Class Exercise 10: Modelling Geographical Accessibility",
    "section": "3.1 Importing Distance Matrix",
    "text": "3.1 Importing Distance Matrix\nNext, we will use read_csv() to import the distance matrix for our analysis. The imported object is a tibble dataframe called ODMatrix\n\nODMatrix <- read_csv(\"In-Class_Ex10/data/aspatial/OD_Matrix.csv\", skip = 0)\n\nRows: 375000 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (6): origin_id, destination_id, entry_cost, network_cost, exit_cost, tot...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "exercises/icex10.html#tidying-distance-matrix",
    "href": "exercises/icex10.html#tidying-distance-matrix",
    "title": "In-Class Exercise 10: Modelling Geographical Accessibility",
    "section": "3.2 Tidying Distance Matrix",
    "text": "3.2 Tidying Distance Matrix\nBy selecting the necessary columns and pivot_wider(), we convert the data into an OD matrix where the destination_ids are the column fields and origin_ids are the row fields.\n\ndistmat <- ODMatrix %>%\n  select(origin_id, destination_id, total_cost) %>%\n  pivot_wider(names_from = destination_id, values_from = total_cost)%>%\n  select(c(-c('origin_id')))\n\nAs SVY21 is in metres, we will convert it to kilometres by dividing by 1000.\n\ndistmat_km <- as.matrix(distmat/1000)"
  },
  {
    "objectID": "exercises/icex10.html#computing-hansens-accessibility",
    "href": "exercises/icex10.html#computing-hansens-accessibility",
    "title": "In-Class Exercise 10: Modelling Geographical Accessibility",
    "section": "4.1 Computing Hansen’s Accessibility",
    "text": "4.1 Computing Hansen’s Accessibility\n\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 2, \n                            family = \"Hansen\"))\n\nThe default field name is very long, let us rename it to accHansen.\n\ncolnames(acc_Hansen) <- \"accHansen\"\n\nNext, we will convert it into tibble format using the code below:\n\nacc_Hansen <- as_tibble(acc_Hansen)\n\nLastly, we use bind_cols() to joint the acc_Hansen tibble dataframe with the hexagons simple features dataframe below:\n\n\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)"
  },
  {
    "objectID": "exercises/icex10.html#visualising-hansens-accessibility",
    "href": "exercises/icex10.html#visualising-hansens-accessibility",
    "title": "In-Class Exercise 10: Modelling Geographical Accessibility",
    "section": "4.2 Visualising Hansen’s Accessibility",
    "text": "4.2 Visualising Hansen’s Accessibility\n\n4.2.1 Extracting Map Extents\nFirstly, we will extract the map extents using the hexagons simple dataframe using st_bbox()\n\nmapex <- st_bbox(hexagons)\n\nUsing the code chunk below, we create a high quality cartographic map of accessibility to eldercare in Singapore.\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\ntm_shape(hexagon_Hansen,\n         bbox = mapex) + \n  tm_fill(col = \"accHansen\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: Hansen method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)"
  }
]